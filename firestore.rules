/**
 * Core Philosophy: This ruleset enforces a strict, user-centric security model. Data is primarily controlled by the user who creates it.
 * Access is granted based on explicit ownership (e.g., a user's own profile or routes) or participation in a shared transaction
 * (e.g., a rider and driver involved in a ride request). The default posture is to deny access, granting permissions only when
 * explicitly defined.
 *
 * Data Structure: The data is organized into a mix of user-scoped and top-level collections.
 * - `/userProfiles/{userProfileId}`: Stores private user data, accessible only to the owner.
 * - `/users/{userId}/routes/{routeId}`: A user-scoped subcollection ensuring that a driver's routes are private to them.
 * - `/rideRequests`, `/deliveryRequests`, `/bookingConfirmations`, `/userFeedback`: Top-level collections for transactional data.
 *   Access to these documents is controlled by denormalized user IDs (e.g., `riderId`, `driverId`, `senderId`) stored directly
 *   on the documents themselves.
 *
 * Key Security Decisions:
 * - No Global Access: There are no admin roles. All permissions are derived from document data.
 * - User Privacy: Listing users is disabled (`/userProfiles`). A user can only read their own profile.
 * - Secure Queries: Listing is disabled on shared collections (`rideRequests`, etc.) to prevent data leakage, unless a query is properly scoped to a user. Clients must query
 *   for documents they are explicitly a party to (e.g., by their `riderId`).
 * - Ownership Integrity: For all created documents, the rules validate that the creator's ID is set correctly and cannot be
 *   changed on subsequent updates.
 *
 * Denormalization for Authorization:
 * This ruleset relies on denormalizing ownership and participant IDs onto documents to enable fast and secure authorization.
 * For example, a `rideRequests` document must contain both the `riderId` and the `driverId` to allow both parties to read it
 * without requiring slow and costly `get()` calls to other collections in the rules.
 *
 * Structural Segregation:
 * The use of the `/users/{userId}/routes/` subcollection path is a deliberate choice. It structurally separates one user's private
 * data from another's, making security rules for listing and access simple, performant, and highly secure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Use for update/delete to ensure the document exists before applying the rule.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Checks if the requesting user is one of the specified participants in a document.
    // Assumes participant IDs are denormalized onto the document.
    function isParticipant(docData) {
      return isSignedIn() && (
        request.auth.uid == docData.driverId ||
        request.auth.uid == docData.riderId ||
        request.auth.uid == docData.senderId ||
        request.auth.uid == docData.requesterId ||
        (docData.participantIds != null && request.auth.uid in docData.participantIds)
      );
    }

    // Validates that the creator of a document is the currently signed-in user.
    function isCreator(creatorId) {
      return isSignedIn() && request.auth.uid == creatorId;
    }

    /**
     * @description Manages user profiles. A user can create, read, update, and delete only their own profile.
     * @path /userProfiles/{userProfileId}
     * @allow (create) A new user signing up: `auth.uid == 'user_abc'` creates document `'user_abc'`.
     * @deny (get) A user trying to read another's profile: `auth.uid == 'user_xyz'` reads document `'user_abc'`.
     * @principle Restricts access to a user's own private data tree.
     */
    match /userProfiles/{userProfileId} {
      allow get: if isOwner(userProfileId);
      allow list: if false;
      allow create: if isOwner(userProfileId) && request.resource.data.id == userProfileId;
      allow update: if isExistingOwner(userProfileId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userProfileId);
    }

    match /users/{userId} {

      /**
       * @description Manages a driver's routes. Only the driver (owner) can manage their routes.
       * @path /users/{userId}/routes/{routeId}
       * @allow (create) A driver creating a new route under their own user ID: `auth.uid == userId`.
       * @deny (get) Another user trying to read a driver's route: `auth.uid != userId`.
       * @principle Enforces strict ownership using a user-scoped subcollection path.
       */
      match /routes/{routeId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.driverId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.driverId == resource.data.driverId;
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Manages ride requests made by riders.
     * @path /rideRequests/{rideRequestId}
     * @allow (create) A signed-in rider creating a request for themselves.
     * @deny (delete) A driver trying to delete a rider's request.
     * @principle Secures a shared resource by checking for participation (`riderId`, `driverId`).
     *             NOTE: `driverId` must be denormalized onto the document for drivers to access it.
     */
    match /rideRequests/{rideRequestId} {
      allow get: if isSignedIn() && isParticipant(resource.data);
      // Allow a driver to list requests assigned to them
      allow list: if isSignedIn() && (request.query.where.driverId == request.auth.uid || request.query.where.riderId == request.auth.uid);
      allow create: if isCreator(request.resource.data.riderId);
      allow update: if resource != null && isSignedIn() && isParticipant(resource.data);
      allow delete: if resource != null && isOwner(resource.data.driverId);
    }

    /**
     * @description Manages delivery requests made by senders.
     * @path /deliveryRequests/{deliveryRequestId}
     * @allow (create) A signed-in sender creating a request for themselves.
     * @deny (delete) A driver trying to delete a sender's request.
     * @principle Secures a shared resource by checking for participation (`senderId`, `driverId`).
     *             NOTE: `driverId` must be denormalized onto the document for drivers to access it.
     */
    match /deliveryRequests/{deliveryRequestId} {
      allow get: if isSignedIn() && isParticipant(resource.data);
      allow list: if false;
      allow create: if isCreator(request.resource.data.senderId);
      allow update: if resource != null && isSignedIn() && isParticipant(resource.data);
      allow delete: if isExistingOwner(resource.data.senderId);
    }

    /**
     * @description Manages confirmed bookings between a driver and a requester (rider/sender).
     * @path /bookingConfirmations/{bookingConfirmationId}
     * @allow (get) A driver or requester reading a booking they are part of.
     * @deny (create) A rider trying to create their own booking confirmation.
     * @principle Secures a shared resource by checking for participation (`driverId`, `requesterId`).
     *             NOTE: The original requester's ID (e.g., `riderId` or `senderId`) must be denormalized
     *             onto this document as `requesterId` for authorization to work.
     */
    match /bookingConfirmations/{bookingConfirmationId} {
      allow get: if isSignedIn() && isParticipant(resource.data);
      allow list: if isSignedIn() && (request.query.where.driverId == request.auth.uid || request.query.where.riderId == request.auth.uid);
      allow create: if isCreator(request.resource.data.driverId);
      allow update: if resource != null && isOwner(resource.data.driverId);
      allow delete: if isExistingOwner(resource.data.driverId);
    }

    /**
     * @description Manages feedback left for drivers.
     * @path /userFeedback/{userFeedbackId}
     * @allow (get) A driver viewing feedback they received.
     * @deny (update) A driver trying to modify feedback left for them.
     * @principle Enforces ownership for writes and shared access for reads.
     */
    match /userFeedback/{userFeedbackId} {
      // CRITICAL: Cannot implement full security. The 'UserFeedback' entity is missing an 'authorId' or 'creatorId' field.
      // Assuming a denormalized 'authorId' field exists for authorization checks.
      allow get: if isSignedIn() && (isOwner(resource.data.driverId) || isOwner(resource.data.authorId));
      allow list: if false;
      allow create: if false; // TODO: Add create validation (e.g., isCreator(request.resource.data.authorId)) once schema includes an 'authorId'.
      allow update: if false; // TODO: Add update validation (e.g., isExistingOwner(resource.data.authorId)) once schema includes an 'authorId'.
      allow delete: if false; // TODO: Add delete validation (e.g., isExistingOwner(resource.data.authorId)) once schema includes an 'authorId'.
    }

    /**
     * @description Manages conversations between users.
     * @path /conversations/{conversationId}
     * @allow (read, write) A user who is a participant in the conversation.
     * @principle Secures conversations by checking for participation in the `participantIds` array.
     */
    match /conversations/{conversationId} {
      allow get: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow list: if isSignedIn() && request.query.where.participantIds.hasAny([request.auth.uid]);
      allow create, update, delete: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      
      /**
       * @description Manages messages within a conversation.
       * @path /conversations/{conversationId}/messages/{messageId}
       * @allow (read, write) A user who is a participant in the parent conversation.
       * @principle Inherits security from the parent conversation document.
       */
      match /messages/{messageId} {
        allow read, create: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]);
        allow list: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]);
        allow update, delete: if false; // Messages are immutable
      }
    }
  }
}
